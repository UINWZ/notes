# 多媒体

[TOC]

# 1.计算机表示图形的几种方式
	多媒体:(包含文字  图片	音频		视频)
	图形的大小 = 图片的总像素 * 每个像素的大小
	单色 每个像素最多可以表示2种颜色  只需要使用长度为1的二进制位来表示 那么每个像素占1/8byte

	16色 每个像素最多可以表示16种颜色 0000 - 1111 那么只需要使用长度为4的二进制表示 那么每个像素占1/2个byte

	256色 每个像素最多可以表示256种颜色  0000 0000 - 1111 1111  那么只需要使用长度8的二进制位表示 那么每个像素占1byte 

	24位 rgb 
       r 1byte   0-255
       g 1byte  0-255
       b 1byte  0-255     那么一个像素占3byte 
jpg 格式
png 格式 

**Android采用的是png格式**
	
#2. 缩放加载加载大图片
>09-14 00:59:51.813: E/AndroidRuntime(2128): Caused by: java.lang.OutOfMemoryError
>09-14 00:59:51.813: E/dalvikvm-heap(2128): Out of memory on a 30720012-byte allocation.

在Android下采用ARGB(A表示透明度)来表示颜色   每个像素占4byte <br/>
所以需要考虑的问题:

- 动态获取图片的分辨率
- 动态获取手机的分辨率

***实现步骤***

1. 获取手机的宽和高

		//1.获取屏幕的分辨率  宽和高
			WindowManager wm = (WindowManager) getSystemService(Context.WINDOW_SERVICE);
			Point point = new Point();
			wm.getDefaultDisplay().getSize(point);   //获取屏幕的大小 并将信息放到point里面
			int screenWidth = point.x;
			int screenHeight = point.y;

2. 获取图片的宽和高

		//2.获取图片的分辨率  宽和高
		//创建bitmap工厂的配置参数
		Options option = new Options();
		   //这个设置为true 则不返回bitmap直接返回null  然后decodeFile()方法将图片的信息封装到Options里面
		option.inJustDecodeBounds = true;
		//根据路径加载图片  将图片转换成bitmap
		BitmapFactory.decodeFile(Environment.getExternalStorageDirectory()+"/dog.jpg",option);
		int imgWidth = option.outWidth;
		int imgHeight = option.outHeight;

3. 计算缩放比

		int scale = 1;
		int scalex = imgWidth/screenWidth;
		int scaley = imgHeight/screenHeight;
		//挑选其中缩放比较大的来
		if(scalex>scale && scalex>scaley){
			scale = scalex;
		}
		if(scaley>scale && scaley>scalex){
			scale = scaley;
		}

4. 按照缩放比显示图片

		//4.设置图片的缩放比 ,用来节约内存
		option.inSampleSize = scale;
		option.inJustDecodeBounds = false;   //设置这个为false   不然会返回null
		Bitmap bitmap = BitmapFactory.decodeFile(Environment.getExternalStorageDirectory()+"/dog.jpg", option);
		
		//5.设置图片
		iv_img.setImageBitmap(bitmap);  

# 3. 创建原图的副本

		//2.创建副本   copy原图
		Bitmap copyBitmap = Bitmap.createBitmap(srcBitmap.getWidth(), srcBitmap.getHeight(), srcBitmap.getConfig());
		//2.1 创建画布   以copyBitmap为模型   
		Canvas canvas = new Canvas(copyBitmap);
		//2.2 创建画笔
		Paint paint = new Paint();
		//2.3 开始作画    srcBitmap参考原图作画
		canvas.drawBitmap(srcBitmap, new Matrix(), paint);

# 4. 图形的处理api

- 旋转

		// 参数 旋转角度,旋转的中点x,y
		matrix.setRotate(degrees, srcBitmap.getWidth() / 2,srcBitmap.getHeight() / 2);
- 缩放 `matrix.setScale(0.5f, 0.5f);`
- 位移  `matrix.setTranslate(80, 0);`
- 倒影效果

		matrix.setScale(1.0f, -1.0f);    //x轴不变      y轴反转
		//post是在上一次修改的基础上进行修改,set则是每次都是新的变化   会覆盖上一次的修改
		matrix.postTranslate(0, srcBitmap.getHeight());
- 镜面效果

		matrix.setScale(-1.0f, 1.0f);
		matrix.postTranslate(srcBitmap.getWidth(), 0);
- 设置像素点透明
`alterbBitmap.setPixel((int)event.getX()+i, (int)event.getY()+j, Color.TRANSPARENT);`

# 5. 使用MediaPlayer播放音频文件
>作用:这个类可用于播放音频或者视频

# 6. 百度音乐盒完成

1. 获取当前歌曲进度和总时长
		
		private void updateSeekBar() {
		//6. 获取音乐文件的总时长  Gets the duration of the file.
		final int duration = mediaPlayer.getDuration();
		//7. 构造定时器
		Timer timer = new Timer();
		//7.1 创建任务  
		TimerTask timerTask = new TimerTask() {
			
			@Override
			public void run() {
				
				//8. 获取歌曲的当前进度
				int currentPosition = mediaPlayer.getCurrentPosition();
				
				//9. 通过handler发送歌曲的信息到Activity更新UI
				//9.1 通过将数据封装到Message中
				Message msg = new Message();
				//9.2 封装多条数据到Message中     将那些数据封装到Bundle中,其实Bundle底层就是Map
				Bundle bundle = new Bundle();
				bundle.putInt("duration", duration);
				bundle.putInt("currentPosition", currentPosition);
				msg.setData(bundle);
				
				//10. 发送数据
				MainActivity.handler.sendMessage(msg);
				
			}
		};
		//7.2 300毫秒后 每隔1秒执行一次任务
		timer.schedule(timerTask, 300, 1000);   //每隔1秒获取歌曲的进度
		
	}

2. 在服务中添加一个播放进度的方法   

		/**
		 * 设置播放音乐指定位置的方法
		 * @param position  该位置由进度条拖动时提供
		 */
		private void seekToPosition(int position){
			mediaPlayer.seekTo(position);
		}

3. 通过handler将数据传递到Activity更新UI
4. SeekBar处理数据<br/>
`sb_seekm.setMax(duration);   //设置进度条最大值`
`sb_seekm.setProgress(currentPosition);  //设置进度条当前进度`

# 7. SurfaceView介绍

- SurfaceView控件是一个重量级控件
- 内部维护了2个线程
	* A 获取数据    负责显示
	* B 负责显示    获取数据

- 它直接可以在子线程更新UI   与进度相关的控件可以直接在子线程更新Ui

				//找到控件 
		final SurfaceView sfv = (SurfaceView) findViewById(R.id.sfv);
			
			
			final SurfaceHolder surfaceHolder = sfv.getHolder();
			
			//添加一个callback
			surfaceHolder.addCallback(new Callback() {
				//当surfaceview销毁的时候调用
				@Override
				public void surfaceDestroyed(SurfaceHolder holder) {
					System.out.println("surfaceDestroyed");
					if (player!=null && player.isPlaying()) {
						
						//获取当前视频播放的位置
						
						currentPosition = player.getCurrentPosition();
						player.stop(); 
						
					}
					
				}
				
				//当surfaceview 初始化了
				@Override
				public void surfaceCreated(SurfaceHolder holder) {
					//[1]初始化mediaplayer 
					  player = new MediaPlayer();
					
					//[2]设置要播放的资源  path 可以是本地也可是网络路径 
					try {
						player.setDataSource("http://192.168.13.89:8080/cc.MP4");
						
						//[2.1]设置播放视频的内容 SurfaceHolder  是用来维护视频播放的内容
						player.setDisplay(surfaceHolder);
						
						//[3]准备播放 
		//						player.prepare();
						player.prepareAsync(); 
						//设置一个准备完成的监听
						player.setOnPreparedListener(new OnPreparedListener() {
							
							@Override
							public void onPrepared(MediaPlayer mp) {
								//[4]开始播放 
								player.start();
								//[5]继续上次的位置继续播放 
								player.seekTo(currentPosition);
								
							}
						});
						
						
						
					} catch (Exception e) {
						e.printStackTrace();
					}
				}
				
				@Override
				public void surfaceChanged(SurfaceHolder holder, int format, int width,
						int height) {
					
				}
			});


###补充1 VideoView
- 这个控件就是对SurfaceView和MediaPlayer进行封装
- MediaPlayer 播放视频只支持3gp  mp4格式

###补充2 vitamio框架
>vitamio框架是开源的,可以播放大多数视频格式的框架.

# 8. 照相和录像

	// create Intent to take a picture and return control to the calling
			// application
			Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);

			File file = new File(Environment.getExternalStorageDirectory(),
					"1.png");
			intent.putExtra(MediaStore.EXTRA_OUTPUT, Uri.fromFile(file));

			// start the image capture Intent
			startActivityForResult(intent, 1);